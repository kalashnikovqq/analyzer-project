from typing import List, Tuple, Dict
from .text_preprocessor import TextPreprocessor

class AspectCategorizer:
    
    def __init__(self, preprocessor: TextPreprocessor):
        self.preprocessor = preprocessor
        self._categories = {
            'качество': [
                'качеств', 'добротн', 'прочн', 'крепк', 'надежн', 'долговечн', 'брак', 
                'поломк', 'сломал', 'разбит', 'треснул', 'порван', 'погнут', 'царапин',
                'ржавчин', 'материал', 'основ', 'краск', 'крашен', 'цвет', 'окраск',
                'долго служит', 'испортил', 'потрескал', 'рассохл'
            ],
            'функциональность': [
                'функц', 'возможност', 'опции', 'настройк', 'режим', 'работ', 'не работает',
                'функционир', 'делает', 'производит', 'создает', 'выполня', 'механизм', 
                'привод', 'мотор', 'двигател', 'ход', 'управлен', 'поломал', 'сломал',
                'перестал', 'глюк', 'баг', 'ошибк', 'зависа', 'тормоз', 'быстро', 'медленно'
            ],
            'дизайн': [
                'дизайн', 'вид', 'внешн', 'внешвид', 'выгляд', 'красив', 'стильн', 'модн',
                'современ', 'цвет', 'расцвет', 'блест', 'матов', 'глянц', 'текстур',
                'узор', 'рисун', 'форм', 'фактур', 'эстетик', 'эстетичн'
            ],
            'удобство': [
                'удоб', 'комфорт', 'эргоном', 'держать', 'держится', 'использова', 'пользова',
                'просто', 'сложно', 'управлен', 'кнопк', 'интерфейс', 'меню', 'тяжел', 'легк',
                'неудоб', 'громоздк', 'компакт', 'помеща', 'регулиров', 'настра', 
                'понятн', 'интуит', 'логичн', 'карман', 'ножк', 'ручк', 'рукоят'
            ],
            'цена': [
                'цен', 'дорог', 'дешев', 'доступн', 'стоит', 'стоимост', 'недорог', 'бюджетн',
                'дешевизн', 'экономичн', 'выгодн', 'скидк', 'акци', 'переплат', 'оправдыв',
                'оправдан', 'окупа', 'вложени', 'своих денег'
            ],
            'комплектация': [
                'комплект', 'набор', 'коробк', 'упаковк', 'инструкц', 'мануал', 'руководств',
                'документ', 'в комплекте', 'аксессуар', 'принадлежност', 'поставк', 
                'запасн', 'дополнительн', 'чехол', 'адаптер', 'запчаст', 'насадк'
            ],
            'размер': [
                'размер', 'больш', 'маленьк', 'габарит', 'объем', 'длин', 'коротк', 'широк',
                'узк', 'высок', 'низк', 'компакт', 'миниатюрн', 'громоздк', 'тонк', 'толст',
                'тяжел', 'легк', 'вес', 'весит', 'объемн', 'места', 'место'
            ],
            'доставка': [
                'доставк', 'привез', 'куръер', 'почт', 'транспортировк', 'упаковк', 'коробк',
                'посылк', 'трек', 'отследить', 'отслежива', 'трекинг', 'получени', 'пункт',
                'пвз', 'постамат', 'магазин', 'пришел', 'пришл', 'задержк', 'быстро'
            ]
        }
    
    def categorize_aspects(self, aspects: List[Tuple[str, int]]) -> Dict[str, List[Tuple[str, int]]]:
        result = {category: [] for category in self._categories}
        result['другое'] = []
        
        for aspect, count in aspects:
            lemma = self.preprocessor.lemmatize_text(aspect.lower())
            categorized = False
            
            for category, keywords in self._categories.items():
                if any(keyword in lemma for keyword in keywords):
                    result[category].append((aspect, count))
                    categorized = True
                    break
            
            if not categorized:
                result['другое'].append((aspect, count))
        
        return {k: v for k, v in result.items() if v} 